<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas ğŸ„</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Microsoft YaHei', sans-serif; }
        #canvas { display: block; position: fixed; top: 0; left: 0; }

        .title {
            position: fixed; top: 5%; left: 50%; transform: translateX(-50%);
            font-family: 'Great Vibes', cursive; font-size: clamp(2rem, 8vw, 4.5rem);
            color: #ffd700; text-shadow: 0 0 20px #ffa500, 0 0 40px #ff8c00, 0 0 60px #ff6600;
            z-index: 100; pointer-events: none;
            opacity: 0; transition: opacity 1.5s ease;
            white-space: nowrap;
        }
        .title.show { opacity: 1; animation: glow 2s ease-in-out infinite alternate; }
        @keyframes glow {
            from { text-shadow: 0 0 20px #ffa500, 0 0 40px #ff8c00; }
            to { text-shadow: 0 0 30px #ffd700, 0 0 60px #ffa500, 0 0 80px #ff8c00; }
        }

        .subtitle {
            position: fixed; top: 13%; left: 50%; transform: translateX(-50%);
            font-size: clamp(0.9rem, 3vw, 1.3rem); color: rgba(255,255,255,0.8);
            z-index: 100; pointer-events: none; text-align: center;
            opacity: 0; transition: opacity 1.5s ease 0.5s;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        .subtitle.show { opacity: 1; }

        .hint {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 13px; text-align: center;
            pointer-events: none; z-index: 100;
            opacity: 0; transition: opacity 1s ease;
        }
        .hint.show { opacity: 1; }

        /* å¼€åœºæç¤º */
        .start-hint {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #0a0a20 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; cursor: pointer; transition: opacity 1s ease;
        }
        .start-hint.hidden { opacity: 0; pointer-events: none; }
        .start-hint h1 {
            font-family: 'Great Vibes', cursive; font-size: clamp(2.5rem, 10vw, 5rem);
            color: #ffd700; margin-bottom: 30px;
            text-shadow: 0 0 30px #ffa500;
            animation: pulse 2s ease-in-out infinite;
        }
        .start-hint p { color: rgba(255,255,255,0.6); font-size: 16px; animation: blink 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.05)} }
        @keyframes blink { 0%,100%{opacity:0.6} 50%{opacity:1} }

        .start-hint .stars {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
        .start-hint .star {
            position: absolute; width: 3px; height: 3px; background: #fff; border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }
        @keyframes twinkle { 0%,100%{opacity:0.3} 50%{opacity:1} }

        /* ç…§ç‰‡æŸ¥çœ‹å™¨ - å‡çº§ç‰ˆ */
        .photo-viewer {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); backdrop-filter: blur(15px); z-index: 3000;
            justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.5s ease;
        }
        .photo-viewer.show { display: flex; opacity: 1; }
        .photo-viewer.fade-out { opacity: 0; }
        .photo-container {
            position: relative; max-width: 90%; max-height: 80%;
            animation: zoomIn 0.4s cubic-bezier(0.175,0.885,0.32,1.275);
        }
        @keyframes zoomIn { from{transform:scale(0.5);opacity:0} to{transform:scale(1);opacity:1} }
        .photo-container img {
            max-width: 85vw; max-height: 70vh; border-radius: 15px;
            box-shadow: 0 0 50px rgba(255,180,200,0.3);
            border: 3px solid rgba(255,255,255,0.2);
        }
        .photo-caption {
            text-align: center; color: #fff; font-size: 1.3em; margin-top: 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        .photo-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            width: 50px; height: 50px; background: rgba(255,255,255,0.15);
            border: none; border-radius: 50%; color: #fff; font-size: 24px;
            cursor: pointer; transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        .photo-nav:hover { background: rgba(255,255,255,0.3); transform: translateY(-50%) scale(1.1); }
        .photo-nav.prev { left: -70px; }
        .photo-nav.next { right: -70px; }
        .photo-close {
            position: absolute; top: -50px; right: 0; width: 40px; height: 40px;
            background: rgba(255,255,255,0.1); border: none; border-radius: 50%;
            color: #fff; font-size: 24px; cursor: pointer; transition: all 0.3s;
        }
        .photo-close:hover { background: rgba(255,0,0,0.3); transform: rotate(90deg); }
        .photo-counter {
            position: absolute; bottom: -40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-size: 14px;
        }
        .photo-dots {
            display: flex; gap: 8px; justify-content: center; margin-top: 15px;
        }
        .photo-dot {
            width: 10px; height: 10px; border-radius: 50%; background: rgba(255,255,255,0.3);
            cursor: pointer; transition: all 0.3s;
        }
        .photo-dot.active { background: #ffd700; transform: scale(1.2); }

        /* ç¤¼ç‰©å¼¹çª— */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); z-index: 3000;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: linear-gradient(145deg, #fff, #f5f5f5); border-radius: 20px;
            max-width: 90%; max-height: 80%; overflow: hidden;
            animation: popIn 0.4s cubic-bezier(0.175,0.885,0.32,1.275);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        @keyframes popIn { from{transform:scale(0.7);opacity:0} to{transform:scale(1);opacity:1} }
        .close-btn {
            position: absolute; top: 12px; right: 16px; font-size: 26px; color: #999;
            cursor: pointer; width: 40px; height: 40px; display: flex; align-items: center;
            justify-content: center; border-radius: 50%; transition: all 0.3s; background: none; border: none;
        }
        .close-btn:hover { color: #ff4444; background: rgba(255,0,0,0.1); transform: rotate(90deg); }

        .gift-modal { padding: 45px 40px; text-align: center; background: linear-gradient(145deg, #fff8f8, #fff); min-width: 300px; position: relative; }
        .gift-message h2 { color: #c41e3a; font-size: 2em; margin-bottom: 25px; }
        .love-message { font-size: 1.25em; line-height: 2; color: #555; }
        .highlight { color: #c41e3a; font-size: 1.4em; font-weight: bold; display: block; margin-top: 12px; }
        .hearts { font-size: 2.5em; margin-top: 25px; animation: beat 1s infinite; }
        @keyframes beat { 0%,100%{transform:scale(1)} 50%{transform:scale(1.15)} }

        /* ç‚¹å‡»çˆ±å¿ƒçˆ†ç‚¸ç‰¹æ•ˆ */
        @keyframes heartBurst {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1); opacity: 0; }
        }
        @keyframes bigHeartPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* ä¾§è¾¹æ”¶é›†çš„ç…§ç‰‡ */
        .side-photos {
            position: fixed; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 15px;
            z-index: 100; pointer-events: none;
        }
        .side-photos.left { left: 20px; }
        .side-photos.right { right: 20px; }
        .side-photo-slot {
            width: 140px; height: 140px; border: 3px solid rgba(255,100,150,0.5);
            border-radius: 12px; overflow: hidden; opacity: 0;
            transition: all 0.5s ease; background: rgba(0,0,0,0.3);
            box-shadow: 0 0 20px rgba(255,100,150,0.3);
        }
        .side-photo-slot.filled {
            opacity: 1; pointer-events: auto; cursor: pointer;
            border-color: rgba(255,200,220,0.8);
            animation: photoAppear 0.6s ease-out;
        }
        .side-photo-slot img {
            width: 100%; height: 100%; object-fit: cover;
        }
        @keyframes photoAppear {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        @media (max-width: 600px) {
            .photo-nav { width: 40px; height: 40px; font-size: 20px; }
            .photo-nav.prev { left: 10px; }
            .photo-nav.next { right: 10px; }
            .photo-close { top: 10px; right: 10px; }
            .title { top: 3%; }
            .subtitle { top: 11%; }
            .gift-modal { padding: 30px 20px; min-width: auto; width: calc(100% - 40px); }
            .gift-message h2 { font-size: 1.5em; }
            .love-message { font-size: 1.1em; }
            .side-photos { gap: 10px; }
            .side-photos.left { left: 10px; }
            .side-photos.right { right: 10px; }
            .side-photo-slot { width: 80px; height: 80px; }
        }
    </style>
</head>
<body>
    <!-- å¼€åœºç‚¹å‡»æç¤º -->
    <div class="start-hint" id="startHint">
        <div class="stars" id="bgStars"></div>
        <h1>ğŸ„ Merry Christmas</h1>
        <p>ç‚¹å‡»å±å¹•å¼€å§‹ä½ çš„æƒŠå–œ âœ¨</p>
    </div>

    <canvas id="canvas"></canvas>
    <div class="title" id="title">Merry Christmas</div>
    <div class="subtitle" id="subtitle">é‡è§ä½ ï¼Œæ˜¯æœ€ç¾çš„åœ£è¯ç¤¼ç‰© ğŸ’•</div>
    <div class="hint" id="hint">âœ¨ ç‚¹å‡»ç…§ç‰‡æŸ¥çœ‹å›å¿† Â· ç‚¹å‡»ç¤¼ç‰©ç›’æŠ½å¥– âœ¨</div>

    <!-- ä¾§è¾¹æ”¶é›†çš„ç…§ç‰‡ -->
    <div class="side-photos left" id="leftPhotos">
        <div class="side-photo-slot" data-slot="0"></div>
        <div class="side-photo-slot" data-slot="1"></div>
        <div class="side-photo-slot" data-slot="2"></div>
    </div>
    <div class="side-photos right" id="rightPhotos">
        <div class="side-photo-slot" data-slot="3"></div>
        <div class="side-photo-slot" data-slot="4"></div>
        <div class="side-photo-slot" data-slot="5"></div>
    </div>

    <!-- å‡çº§ç‰ˆç…§ç‰‡æŸ¥çœ‹å™¨ -->
    <div class="photo-viewer" id="photoViewer">
        <div class="photo-container">
            <button class="photo-close" onclick="closePhotoViewer()">Ã—</button>
            <button class="photo-nav prev" onclick="prevPhoto()">â®</button>
            <img id="viewerImage" src="">
            <button class="photo-nav next" onclick="nextPhoto()">â¯</button>
            <p class="photo-caption" id="viewerCaption"></p>
            <div class="photo-dots" id="photoDots"></div>
        </div>
    </div>

    <div class="modal" id="giftModal">
        <div class="modal-content gift-modal">
            <button class="close-btn" onclick="closeGiftModal()">Ã—</button>
            <div class="gift-message">
                <h2 id="giftTitle">ğŸ æŠ½å¥–æ—¶é—´ ğŸ</h2>
                <div id="prizeEmoji" style="font-size: 4em; margin: 20px 0;">ğŸ</div>
                <p class="love-message" id="loveMessage"></p>
                <div class="hearts">ğŸ’•</div>
            </div>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="bgMusic" loop>
        <source src="" type="audio/ogg">
        <source src="" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
// ==================== é…ç½® ====================
const CONFIG = {
    herName: "å°æ¢å®è´",
    subtitle: "é‡è§ä½ ï¼Œæ˜¯æœ€ç¾çš„åœ£è¯ç¤¼ç‰© ğŸ’•",
    photos: [
        { src: "photos/1.jpg", caption: "æœ€ç¾çš„ä½  ğŸ’•" },
        { src: "photos/2.jpg", caption: "ä¸€èµ·çœ‹è¿‡çš„é£æ™¯ ğŸŒ…" },
        { src: "photos/3.jpg", caption: "é‚£å¤©ä½ ç¬‘å¾—çœŸå¥½çœ‹ ğŸ˜Š" },
        { src: "photos/4.jpg", caption: "ç¾å¥½çš„å›å¿† âœ¨" },
        { src: "photos/5.jpg", caption: "æ°¸è¿œè®°å¾—è¿™ä¸€åˆ» ğŸ’–" },
        { src: "photos/6.jpg", caption: "æœ‰ä½ çœŸå¥½ ğŸ¥°" },
    ],
    // æŠ½å¥–å¥–å“é…ç½®
    prizes: [
        {
            emoji: "ğŸ§§",
            title: "520ç°é‡‘çº¢åŒ…",
            desc: "æ­å–œä½ æŠ½ä¸­ 520å…ƒç°é‡‘çº¢åŒ…ï¼<br><br>è¿™æ˜¯æˆ‘å¯¹ä½ æ»¡æ»¡çš„çˆ±æ„~<br>è®°å¾—æ‰¾æˆ‘å…‘æ¢å“¦ï¼",
        },
        {
            emoji: "ğŸ‘—",
            title: "è¡£æœåˆ¸",
            desc: "æ­å–œä½ æŠ½ä¸­ è¡£æœåˆ¸ ä¸€å¼ ï¼<br><br>å¸¦ä½ å»ä¹°ä¸€ä»¶ä½ å–œæ¬¢çš„è¡£æœ~<br>éšæ—¶å¯ä»¥å…‘æ¢ï¼",
        },
        {
            emoji: "ğŸ’«",
            title: "æ„¿æœ›å¡",
            desc: "æ­å–œä½ æŠ½ä¸­ æ„¿æœ›å¡ ä¸€å¼ ï¼<br><br>å¯ä»¥è®¸ä¸€ä¸ªæ„¿æœ›è®©æˆ‘å¸®ä½ å®ç°~<br>ï¼ˆåœ¨æˆ‘èƒ½åŠ›èŒƒå›´å†…å“¦ï¼‰",
        }
    ],
    musicUrl: "https://upload.wikimedia.org/wikipedia/commons/e/e0/Jingle_Bells_Instrumental.ogg"
};

// æŠ½å¥–çŠ¶æ€
let hasDrawn = false; // æ˜¯å¦å·²ç»æŠ½è¿‡å¥–
let drawnPrize = null; // æŠ½ä¸­çš„å¥–å“

let scene, camera, renderer, controls;
let treeParticles, snowParticles, heartParticles;
let photoOrbitGroups = [];
let giftBoxes = [];
let raycaster, mouse, clickableObjects = [];
let clock = new THREE.Clock();
let isAnimationStarted = false;
let animationPhase = 0;

// å¼€åœºåŠ¨ç”»ç›¸å…³
let introParticles;
let targetPositions = [];
let startPositions = [];

// ç…§ç‰‡æŸ¥çœ‹å™¨çŠ¶æ€
let currentPhotoIndex = 0;

// çƒŸèŠ±ç³»ç»Ÿ
let fireworks = [];

// ==================== å¼€åœºæ˜Ÿæ˜ŸèƒŒæ™¯ ====================
function createBgStars() {
    const container = document.getElementById('bgStars');
    for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 2 + 's';
        star.style.opacity = Math.random() * 0.5 + 0.3;
        container.appendChild(star);
    }
}
createBgStars();

// ==================== ç‚¹å‡»å¼€å§‹ ====================
document.getElementById('startHint').addEventListener('click', startExperience);

function startExperience() {
    const music = document.getElementById('bgMusic');
    music.src = CONFIG.musicUrl;
    music.volume = 0.5;
    music.play().catch(() => {});

    document.getElementById('startHint').classList.add('hidden');
    isAnimationStarted = true;
    animationPhase = 1;

    setTimeout(() => {
        document.getElementById('title').classList.add('show');
        document.getElementById('subtitle').textContent = CONFIG.subtitle;
        document.getElementById('subtitle').classList.add('show');
    }, 3500);

    setTimeout(() => {
        document.getElementById('hint').classList.add('show');
    }, 5000);
}

// ==================== åˆå§‹åŒ– ====================
function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 14);

    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000510);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 8;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2 + 0.3;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.3;
    controls.target.set(0, 3, 0);
    controls.enabled = false;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    createStarField();
    createIntroParticles();
    createSnow();

    window.addEventListener('resize', onResize);
    window.addEventListener('click', onClick);
    window.addEventListener('touchend', onTouch);

    // é”®ç›˜å¯¼èˆª
    document.addEventListener('keydown', handleKeyDown);

    animate();
}

function handleKeyDown(e) {
    if (document.getElementById('photoViewer').classList.contains('show')) {
        if (e.key === 'ArrowLeft') prevPhoto();
        else if (e.key === 'ArrowRight') nextPhoto();
        else if (e.key === 'Escape') closePhotoViewer();
    } else if (e.key === 'Escape') {
        closeGiftModal();
    }
}

// ==================== æ˜Ÿç©ºèƒŒæ™¯ ====================
function createStarField() {
    const count = 2500;
    const positions = new Float32Array(count * 3);
    const sizes = new Float32Array(count);
    for (let i = 0; i < count; i++) {
        const r = 50 + Math.random() * 100;
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos(Math.random() * 2 - 1);
        positions[i*3] = r * Math.sin(p) * Math.cos(t);
        positions[i*3+1] = Math.abs(r * Math.cos(p));
        positions[i*3+2] = r * Math.sin(p) * Math.sin(t);
        sizes[i] = Math.random() * 0.15 + 0.05;
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 });
    scene.add(new THREE.Points(geo, mat));
}

// ==================== å¼€åœºç²’å­ï¼ˆæ±‡èšæˆåœ£è¯æ ‘ï¼‰ ====================
function createIntroParticles() {
    const particleCount = 15000;
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    targetPositions = [];
    startPositions = [];

    for (let i = 0; i < particleCount; i++) {
        const t = Math.random();
        const y = t * 8;
        const maxRadius = 3.2 * (1 - t * 0.9);
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * maxRadius;

        const targetX = Math.cos(angle) * radius;
        const targetY = y;
        const targetZ = Math.sin(angle) * radius;
        targetPositions.push(targetX, targetY, targetZ);

        // ä»æ›´è¿œçš„åœ°æ–¹é£å…¥
        const startAngle = Math.random() * Math.PI * 2;
        const startRadius = 20 + Math.random() * 25;
        const startY = Math.random() * 20 - 8;
        startPositions.push(
            Math.cos(startAngle) * startRadius,
            startY,
            Math.sin(startAngle) * startRadius
        );

        positions[i*3] = startPositions[i*3];
        positions[i*3+1] = startPositions[i*3+1];
        positions[i*3+2] = startPositions[i*3+2];

        const green = new THREE.Color(0x228b22);
        const gold = new THREE.Color(0xffd700);
        const color = green.clone().lerp(gold, t * t);
        const brightness = 0.7 + Math.random() * 0.3;
        colors[i*3] = color.r * brightness;
        colors[i*3+1] = color.g * brightness;
        colors[i*3+2] = color.b * brightness;
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(255,255,200,0.8)');
    gradient.addColorStop(0.5, 'rgba(255,255,100,0.3)');
    gradient.addColorStop(1, 'rgba(255,255,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);

    const material = new THREE.PointsMaterial({
        size: 0.12,
        map: new THREE.CanvasTexture(canvas),
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    introParticles = new THREE.Points(geometry, material);
    scene.add(introParticles);
}

// ==================== é›ªèŠ± ====================
function createSnow() {
    const count = 2000;
    const positions = new Float32Array(count * 3);
    const velocities = [];
    for (let i = 0; i < count; i++) {
        positions[i*3] = (Math.random() - 0.5) * 50;
        positions[i*3+1] = Math.random() * 30;
        positions[i*3+2] = (Math.random() - 0.5) * 50;
        velocities.push({
            y: 0.02 + Math.random() * 0.02,
            x: (Math.random()-0.5)*0.01,
            z: (Math.random()-0.5)*0.01,
            wobble: Math.random() * Math.PI * 2
        });
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // é›ªèŠ±çº¹ç†
    const snowCanvas = document.createElement('canvas');
    snowCanvas.width = snowCanvas.height = 32;
    const sctx = snowCanvas.getContext('2d');
    const sg = sctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    sg.addColorStop(0, 'rgba(255,255,255,1)');
    sg.addColorStop(0.5, 'rgba(255,255,255,0.5)');
    sg.addColorStop(1, 'rgba(255,255,255,0)');
    sctx.fillStyle = sg;
    sctx.fillRect(0, 0, 32, 32);

    const mat = new THREE.PointsMaterial({
        map: new THREE.CanvasTexture(snowCanvas),
        size: 0.15,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });
    snowParticles = new THREE.Points(geo, mat);
    snowParticles.userData = { velocities };
    scene.add(snowParticles);
}

// ==================== çˆ±å¿ƒç²’å­ ====================
function createHeartParticles() {
    const count = 100;
    const positions = new Float32Array(count * 3);
    const velocities = [];

    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 2;
        positions[i*3] = Math.cos(angle) * radius;
        positions[i*3+1] = Math.random() * 8;
        positions[i*3+2] = Math.sin(angle) * radius;
        velocities.push({
            y: 0.01 + Math.random() * 0.02,
            x: (Math.random() - 0.5) * 0.02,
            z: (Math.random() - 0.5) * 0.02,
            life: Math.random()
        });
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // çˆ±å¿ƒçº¹ç†
    const heartCanvas = document.createElement('canvas');
    heartCanvas.width = heartCanvas.height = 64;
    const hctx = heartCanvas.getContext('2d');
    hctx.font = '50px Arial';
    hctx.textAlign = 'center';
    hctx.textBaseline = 'middle';
    hctx.fillText('ğŸ’•', 32, 32);

    const mat = new THREE.PointsMaterial({
        map: new THREE.CanvasTexture(heartCanvas),
        size: 0.5,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    heartParticles = new THREE.Points(geo, mat);
    heartParticles.userData = { velocities };
    scene.add(heartParticles);
}

// ==================== çƒŸèŠ± ====================
function createFirework(x, y, z) {
    const colors = [0xff0000, 0xffd700, 0x00ff00, 0xff69b4, 0x00ffff, 0xff00ff];
    const color = colors[Math.floor(Math.random() * colors.length)];
    const count = 80;
    const positions = new Float32Array(count * 3);
    const velocities = [];

    for (let i = 0; i < count; i++) {
        positions[i*3] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;

        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const speed = 0.1 + Math.random() * 0.15;
        velocities.push({
            x: Math.sin(phi) * Math.cos(theta) * speed,
            y: Math.cos(phi) * speed,
            z: Math.sin(phi) * Math.sin(theta) * speed,
            life: 1
        });
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const mat = new THREE.PointsMaterial({
        color: color,
        size: 0.15,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const firework = new THREE.Points(geo, mat);
    firework.userData = { velocities, age: 0 };
    scene.add(firework);
    fireworks.push(firework);
}

// ==================== åˆ›å»ºè£…é¥°ï¼ˆæ±‡èšå®Œæˆåï¼‰ ====================
let decorationsCreated = false;

function createDecorations() {
    createTreeLights();
    createTreeStar();
    createOrbitingPhotos();
    createGiftBoxes();
    createHeartParticles();
    createGroundDecorations();

    controls.enabled = true;

    // æ”¾çƒŸèŠ±åº†ç¥
    setTimeout(() => {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const x = (Math.random() - 0.5) * 15;
                const y = 10 + Math.random() * 8;
                const z = (Math.random() - 0.5) * 10 - 5;
                createFirework(x, y, z);
            }, i * 400);
        }
    }, 500);
}

function createTreeLights() {
    const lightCount = 100;
    const positions = new Float32Array(lightCount * 3);
    const colors = new Float32Array(lightCount * 3);
    const lightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff];

    for (let i = 0; i < lightCount; i++) {
        const t = Math.random();
        const y = t * 7.5;
        const maxRadius = 2.9 * (1 - t * 0.85);
        const angle = Math.random() * Math.PI * 2;
        const radius = maxRadius * 0.85;

        positions[i*3] = Math.cos(angle) * radius;
        positions[i*3+1] = y + 0.3;
        positions[i*3+2] = Math.sin(angle) * radius;

        const color = new THREE.Color(lightColors[i % lightColors.length]);
        colors[i*3] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
        size: 0.25, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
    const lights = new THREE.Points(geo, mat);
    lights.userData = { type: 'lights' };
    scene.add(lights);
}

function createTreeStar() {
    const group = new THREE.Group();
    const starCount = 500;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.6;
        positions[i*3] = Math.cos(angle) * radius;
        positions[i*3+1] = (Math.random() - 0.5) * 0.4;
        positions[i*3+2] = Math.sin(angle) * radius;
        colors[i*3] = 1;
        colors[i*3+1] = 0.85 + Math.random() * 0.15;
        colors[i*3+2] = 0;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const mat = new THREE.PointsMaterial({ size: 0.18, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
    group.add(new THREE.Points(geo, mat));

    // ä¸­å¿ƒå‘å…‰çƒ
    const coreMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.9 });
    group.add(new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), coreMat));

    group.position.y = 8.5;
    group.userData = { type: 'star' };
    scene.add(group);
}

// ==================== ç¯ç»•ç…§ç‰‡ç³»ç»Ÿ ====================
function createOrbitingPhotos() {
    // åˆ›å»ºå¤šå±‚è½¨é“
    const orbits = [
        { radius: 4.5, height: 2, speed: 0.3, photos: [0, 1] },
        { radius: 5.5, height: 4.5, speed: -0.25, photos: [2, 3] },
        { radius: 4.8, height: 6.5, speed: 0.35, photos: [4, 5] }
    ];

    orbits.forEach((orbit, orbitIndex) => {
        const orbitGroup = new THREE.Group();
        orbitGroup.userData = { speed: orbit.speed, height: orbit.height };

        orbit.photos.forEach((photoIndex, i) => {
            if (photoIndex >= CONFIG.photos.length) return;
            const photo = CONFIG.photos[photoIndex];

            const photoGroup = new THREE.Group();

            // ç™½è‰²ç›¸æ¡†èƒŒæ™¯
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const frame = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 1.3), frameMat);
            frame.position.z = -0.01;
            photoGroup.add(frame);

            // åˆ›å»ºç…§ç‰‡çº¹ç†
            const photoCanvas = document.createElement('canvas');
            photoCanvas.width = 256;
            photoCanvas.height = 256;
            const pctx = photoCanvas.getContext('2d');
            // ç°è‰²èƒŒæ™¯å ä½
            pctx.fillStyle = '#e0e0e0';
            pctx.fillRect(0, 0, 256, 256);
            pctx.fillStyle = '#999';
            pctx.font = '60px Arial';
            pctx.textAlign = 'center';
            pctx.textBaseline = 'middle';
            pctx.fillText('ğŸ“·', 128, 110);
            pctx.font = '24px Arial';
            pctx.fillText('ç…§ç‰‡ ' + (photoIndex + 1), 128, 170);

            const photoTexture = new THREE.CanvasTexture(photoCanvas);
            const photoMat = new THREE.MeshBasicMaterial({
                map: photoTexture,
                side: THREE.DoubleSide
            });

            // ç”¨ Image å¯¹è±¡åŠ è½½å›¾ç‰‡
            const img = new Image();
            img.onload = function() {
                pctx.clearRect(0, 0, 256, 256);
                // å±…ä¸­è£å‰ªç»˜åˆ¶
                const size = Math.min(img.width, img.height);
                const sx = (img.width - size) / 2;
                const sy = (img.height - size) / 2;
                pctx.drawImage(img, sx, sy, size, size, 0, 0, 256, 256);
                photoTexture.needsUpdate = true;
            };
            img.src = photo.src;

            const photoMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), photoMat);
            photoMesh.position.z = 0.01;
            photoMesh.userData = {
                type: 'photo',
                index: photoIndex,
                src: photo.src,
                caption: photo.caption
            };
            photoGroup.add(photoMesh);
            clickableObjects.push(photoMesh);

            // ä½ç½®
            const angle = (i / orbit.photos.length) * Math.PI * 2;
            photoGroup.position.set(
                Math.cos(angle) * orbit.radius,
                0,
                Math.sin(angle) * orbit.radius
            );
            photoGroup.userData = { baseAngle: angle, orbitRadius: orbit.radius };

            orbitGroup.add(photoGroup);
        });

        orbitGroup.position.y = orbit.height;
        photoOrbitGroups.push(orbitGroup);
        scene.add(orbitGroup);
    });

}

function createGiftBoxes() {
    const colors = [
        { box: 0xcc0000, ribbon: 0xffd700 },
        { box: 0x008800, ribbon: 0xff0000 },
        { box: 0x0055cc, ribbon: 0xffff00 }
    ];
    const positions = [{ x: -2.5, z: 4.5 }, { x: 2.5, z: 4.5 }, { x: 0, z: 5.5 }];

    positions.forEach((pos, i) => {
        const gift = new THREE.Group();
        const c = colors[i % colors.length];
        const scale = 0.7 + Math.random() * 0.2;

        // ç›’å­
        const boxGeo = new THREE.BoxGeometry(1, 0.7, 1);
        const boxMat = new THREE.MeshBasicMaterial({ color: c.box });
        const box = new THREE.Mesh(boxGeo, boxMat);
        gift.add(box);

        // ä¸å¸¦
        const rMat = new THREE.MeshBasicMaterial({ color: c.ribbon });
        gift.add(new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.75, 1.05), rMat));
        gift.add(new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.75, 0.12), rMat));

        // è´è¶ç»“
        const bowGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const bow = new THREE.Mesh(bowGeo, rMat);
        bow.position.y = 0.4;
        gift.add(bow);

        gift.position.set(pos.x, -2, pos.z); // ä»ä¸‹æ–¹å¼€å§‹
        gift.scale.setScalar(scale);
        gift.userData = {
            type: 'gift',
            boxIndex: i,  // æ·»åŠ ç›’å­ç´¢å¼•ç”¨äºæŠ½å¥–
            targetY: scale * 0.35,
            phase: i * 0.5,
            appearing: true
        };

        giftBoxes.push(gift);
        clickableObjects.push(box);
        scene.add(gift);
    });
}

function createGroundDecorations() {
    const ballColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffffff];
    for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 2.5 + Math.random() * 2.5;
        const ball = new THREE.Mesh(
            new THREE.SphereGeometry(0.1 + Math.random() * 0.08, 12, 12),
            new THREE.MeshBasicMaterial({ color: ballColors[i % ballColors.length] })
        );
        ball.position.set(Math.cos(angle) * radius, 0.1, Math.sin(angle) * radius);
        scene.add(ball);
    }
}

// ==================== åŠ¨ç”» ====================
let introProgress = 0;

function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    const delta = clock.getDelta();
    controls.update();

    // å¼€åœºç²’å­æ±‡èš
    if (animationPhase === 1 && introParticles) {
        introProgress += 0.006;
        if (introProgress >= 1) {
            introProgress = 1;
            animationPhase = 2;
            if (!decorationsCreated) {
                decorationsCreated = true;
                setTimeout(createDecorations, 300);
            }
        }

        const positions = introParticles.geometry.attributes.position.array;
        const easeProgress = 1 - Math.pow(1 - introProgress, 3);

        for (let i = 0; i < positions.length; i += 3) {
            positions[i] = startPositions[i] + (targetPositions[i] - startPositions[i]) * easeProgress;
            positions[i+1] = startPositions[i+1] + (targetPositions[i+1] - startPositions[i+1]) * easeProgress;
            positions[i+2] = startPositions[i+2] + (targetPositions[i+2] - startPositions[i+2]) * easeProgress;
        }
        introParticles.geometry.attributes.position.needsUpdate = true;
    }

    // æ ‘å¾®åŠ¨
    if (animationPhase === 2 && introParticles) {
        introParticles.rotation.y = Math.sin(t * 0.1) * 0.02;
    }

    // é›ªèŠ±
    if (snowParticles && isAnimationStarted) {
        const pos = snowParticles.geometry.attributes.position.array;
        const vel = snowParticles.userData.velocities;
        for (let i = 0; i < pos.length / 3; i++) {
            vel[i].wobble += 0.02;
            pos[i*3] += vel[i].x + Math.sin(vel[i].wobble) * 0.003;
            pos[i*3+1] -= vel[i].y;
            pos[i*3+2] += vel[i].z;
            if (pos[i*3+1] < 0) {
                pos[i*3+1] = 30;
                pos[i*3] = (Math.random() - 0.5) * 50;
                pos[i*3+2] = (Math.random() - 0.5) * 50;
            }
        }
        snowParticles.geometry.attributes.position.needsUpdate = true;
    }

    // çˆ±å¿ƒç²’å­ä¸Šå‡
    if (heartParticles && animationPhase === 2) {
        const pos = heartParticles.geometry.attributes.position.array;
        const vel = heartParticles.userData.velocities;
        for (let i = 0; i < pos.length / 3; i++) {
            pos[i*3] += vel[i].x;
            pos[i*3+1] += vel[i].y;
            pos[i*3+2] += vel[i].z;
            vel[i].life -= 0.005;

            if (vel[i].life <= 0 || pos[i*3+1] > 15) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2;
                pos[i*3] = Math.cos(angle) * radius;
                pos[i*3+1] = Math.random() * 3;
                pos[i*3+2] = Math.sin(angle) * radius;
                vel[i].life = 1;
            }
        }
        heartParticles.geometry.attributes.position.needsUpdate = true;
    }

    // ç…§ç‰‡ç¯ç»•æ—‹è½¬
    if (animationPhase === 2) {
        photoOrbitGroups.forEach(group => {
            group.rotation.y += group.userData.speed * 0.01;

            // è®©æ¯ä¸ªç…§ç‰‡é¢å‘ç›¸æœº
            group.children.forEach(photoGroup => {
                if (photoGroup.userData.baseAngle !== undefined) {
                    const worldPos = new THREE.Vector3();
                    photoGroup.getWorldPosition(worldPos);

                    // ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº
                    photoGroup.children.forEach(child => {
                        if (child.geometry && child.geometry.type === 'CircleGeometry') {
                            child.lookAt(camera.position);
                        }
                    });

                    // è½»å¾®ä¸Šä¸‹æµ®åŠ¨
                    photoGroup.position.y = Math.sin(t * 0.8 + photoGroup.userData.baseAngle) * 0.1;
                }
            });
        });

        // ç¤¼ç‰©ç›’åŠ¨ç”»
        giftBoxes.forEach(g => {
            if (g.userData.appearing) {
                g.position.y += 0.05;
                if (g.position.y >= g.userData.targetY) {
                    g.position.y = g.userData.targetY;
                    g.userData.appearing = false;
                }
            } else {
                g.position.y = g.userData.targetY + Math.sin(t * 1.5 + g.userData.phase) * 0.05;
                g.rotation.y = Math.sin(t * 0.5 + g.userData.phase) * 0.1;
            }
        });
    }

    // çƒŸèŠ±æ›´æ–°
    for (let i = fireworks.length - 1; i >= 0; i--) {
        const fw = fireworks[i];
        const pos = fw.geometry.attributes.position.array;
        const vel = fw.userData.velocities;
        fw.userData.age += 0.016;

        let allDead = true;
        for (let j = 0; j < pos.length / 3; j++) {
            if (vel[j].life > 0) {
                pos[j*3] += vel[j].x;
                pos[j*3+1] += vel[j].y;
                pos[j*3+2] += vel[j].z;
                vel[j].y -= 0.003; // é‡åŠ›
                vel[j].life -= 0.015;
                allDead = false;
            }
        }
        fw.geometry.attributes.position.needsUpdate = true;
        fw.material.opacity = Math.max(0, 1 - fw.userData.age);

        if (allDead || fw.userData.age > 3) {
            scene.remove(fw);
            fireworks.splice(i, 1);
        }
    }

    // æ ‘é¡¶æ˜Ÿæ˜Ÿè„‰å†²
    scene.children.forEach(child => {
        if (child.userData && child.userData.type === 'star') {
            const scale = 1 + Math.sin(t * 2) * 0.1;
            child.scale.set(scale, scale, scale);
        }
    });

    renderer.render(scene, camera);
}

// ==================== äº‹ä»¶ ====================
function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onClick(e) {
    if (animationPhase < 2) return;
    handleClick(e.clientX, e.clientY);
}
function onTouch(e) {
    if (animationPhase < 2) return;
    if (e.changedTouches.length) handleClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
}

function handleClick(x, y) {
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(clickableObjects, true);
    if (hits.length) {
        let obj = hits[0].object;
        while (obj.parent && !obj.userData.type) obj = obj.parent;
        if (obj.userData.type === 'photo') {
            openPhotoViewer(obj.userData.index);
        } else if (obj.userData.type === 'gift') {
            openGiftModal(obj.userData.boxIndex);
        }
    } else {
        // ç‚¹å‡»ç©ºç™½å¤„ - çˆ±å¿ƒçˆ†ç‚¸ç‰¹æ•ˆ
        createHeartBurst(x, y);
    }
}

// çˆ±å¿ƒçˆ†ç‚¸ç‰¹æ•ˆ
function createHeartBurst(screenX, screenY) {
    const burstContainer = document.createElement('div');
    burstContainer.style.cssText = `
        position: fixed; left: ${screenX}px; top: ${screenY}px;
        pointer-events: none; z-index: 2000;
        transform: translate(-50%, -50%);
    `;
    document.body.appendChild(burstContainer);

    const hearts = ['ğŸ’•', 'â¤ï¸', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'âœ¨', 'ğŸŒŸ'];
    const count = 12;

    for (let i = 0; i < count; i++) {
        const heart = document.createElement('div');
        const angle = (i / count) * Math.PI * 2;
        const distance = 80 + Math.random() * 60;
        const size = 16 + Math.random() * 20;
        const duration = 0.8 + Math.random() * 0.4;

        heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
        heart.style.cssText = `
            position: absolute; font-size: ${size}px;
            left: 0; top: 0; opacity: 1;
            animation: heartBurst ${duration}s ease-out forwards;
            --tx: ${Math.cos(angle) * distance}px;
            --ty: ${Math.sin(angle) * distance}px;
        `;
        burstContainer.appendChild(heart);
    }

    // ä¸­å¿ƒå¤§çˆ±å¿ƒ
    const bigHeart = document.createElement('div');
    bigHeart.textContent = 'ğŸ’–';
    bigHeart.style.cssText = `
        position: absolute; font-size: 50px;
        left: 0; top: 0; transform: translate(-50%, -50%);
        animation: bigHeartPop 0.6s ease-out forwards;
    `;
    burstContainer.appendChild(bigHeart);

    setTimeout(() => burstContainer.remove(), 1500);
}

// ==================== ç…§ç‰‡æŸ¥çœ‹å™¨ ====================
let photoAutoCloseTimer = null;
let viewedPhotos = new Set(); // è¿½è¸ªå·²æŸ¥çœ‹çš„ç…§ç‰‡
let sideSlotIndex = 0; // ä¸‹ä¸€ä¸ªå¯ç”¨çš„ä¾§è¾¹æ§½ä½

// å°†ç…§ç‰‡æ·»åŠ åˆ°ä¾§è¾¹æ§½ä½
function addPhotoToSideSlot(photoIndex) {
    if (viewedPhotos.has(photoIndex)) return; // å·²ç»æ·»åŠ è¿‡äº†
    if (sideSlotIndex >= 6) return; // æ§½ä½å·²æ»¡

    viewedPhotos.add(photoIndex);
    const photo = CONFIG.photos[photoIndex];

    // æ‰¾åˆ°å¯¹åº”çš„æ§½ä½
    const slot = document.querySelector(`.side-photo-slot[data-slot="${sideSlotIndex}"]`);
    if (slot) {
        const img = document.createElement('img');
        img.src = photo.src;
        img.alt = photo.caption;
        img.onerror = function() {
            this.src = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect fill="#ffb6c1" width="100" height="100"/><text x="50" y="60" text-anchor="middle" fill="#fff" font-size="30">ğŸ’•</text></svg>');
        };
        slot.innerHTML = '';
        slot.appendChild(img);
        slot.classList.add('filled');
        slot.onclick = () => openPhotoViewerFromSlot(photoIndex);
        sideSlotIndex++;
    }

    // éšè—è½¨é“ä¸Šçš„åŸå§‹ç…§ç‰‡
    hideOrbitingPhoto(photoIndex);
}

// éšè—è½¨é“ä¸Šçš„ç…§ç‰‡
function hideOrbitingPhoto(photoIndex) {
    clickableObjects.forEach(obj => {
        if (obj.userData.type === 'photo' && obj.userData.index === photoIndex) {
            // æ·¡å‡ºæ•ˆæœ
            const parent = obj.parent;
            if (parent) {
                const fadeOut = () => {
                    if (parent.scale.x > 0.01) {
                        parent.scale.multiplyScalar(0.9);
                        requestAnimationFrame(fadeOut);
                    } else {
                        parent.visible = false;
                    }
                };
                fadeOut();
            }
        }
    });
}

// ä»ä¾§è¾¹æ§½ä½æ‰“å¼€ç…§ç‰‡æŸ¥çœ‹å™¨
function openPhotoViewerFromSlot(index) {
    currentPhotoIndex = index;
    updatePhotoViewer();
    document.getElementById('photoViewer').classList.add('show');
    controls.autoRotate = false;
    // ä¾§è¾¹æ§½ç‚¹å¼€ä¸è‡ªåŠ¨å…³é—­
    clearTimeout(photoAutoCloseTimer);
}

function openPhotoViewer(index) {
    currentPhotoIndex = index;
    updatePhotoViewer();
    document.getElementById('photoViewer').classList.add('show');
    controls.autoRotate = false;
    // ä¸å†è‡ªåŠ¨å…³é—­ï¼Œç”±ç”¨æˆ·æ‰‹åŠ¨å…³é—­
}

function updatePhotoViewer() {
    const photo = CONFIG.photos[currentPhotoIndex];
    const img = document.getElementById('viewerImage');
    img.src = photo.src;
    img.onerror = function() {
        this.src = 'data:image/svg+xml,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="300" height="300"><circle fill="#ffb6c1" cx="150" cy="150" r="150"/><text x="150" y="170" text-anchor="middle" fill="#fff" font-size="80">ğŸ’•</text></svg>');
    };
    document.getElementById('viewerCaption').textContent = photo.caption;

    // æ›´æ–°åœ†ç‚¹
    const dotsContainer = document.getElementById('photoDots');
    dotsContainer.innerHTML = '';
    CONFIG.photos.forEach((_, i) => {
        const dot = document.createElement('div');
        dot.className = 'photo-dot' + (i === currentPhotoIndex ? ' active' : '');
        dot.onclick = () => goToPhoto(i);
        dotsContainer.appendChild(dot);
    });
}

function goToPhoto(index) {
    currentPhotoIndex = index;
    updatePhotoViewer();
}

function prevPhoto() {
    currentPhotoIndex = (currentPhotoIndex - 1 + CONFIG.photos.length) % CONFIG.photos.length;
    updatePhotoViewer();
}

function nextPhoto() {
    currentPhotoIndex = (currentPhotoIndex + 1) % CONFIG.photos.length;
    updatePhotoViewer();
}

function closePhotoViewer() {
    const viewer = document.getElementById('photoViewer');
    viewer.classList.add('fade-out');

    // å°†å½“å‰ç…§ç‰‡æ·»åŠ åˆ°ä¾§è¾¹æ§½ä½ï¼ˆå¦‚æœè¿˜æ²¡æ·»åŠ è¿‡ï¼‰
    addPhotoToSideSlot(currentPhotoIndex);

    setTimeout(() => {
        viewer.classList.remove('show', 'fade-out');
        controls.autoRotate = true;
    }, 500); // 0.5ç§’æ·¡å‡º
}

// ==================== ç¤¼ç‰©å¼¹çª— ====================
function openGiftModal(boxIndex) {
    // å¦‚æœå·²ç»æŠ½è¿‡å¥–äº†
    if (hasDrawn) {
        document.getElementById('giftTitle').innerHTML = `ğŸ ä½ å·²ç»æŠ½è¿‡å•¦ ğŸ`;
        document.getElementById('prizeEmoji').textContent = drawnPrize.emoji;
        document.getElementById('loveMessage').innerHTML = `ä½ æŠ½ä¸­çš„æ˜¯ï¼š<br><br><strong style="font-size:1.3em;color:#c41e3a;">${drawnPrize.title}</strong><br><br>${drawnPrize.desc}<br><br><span style="color:#888;font-size:0.9em;">ğŸ“Œ æ­¤åˆ¸é•¿æœŸæœ‰æ•ˆï¼Œéšæ—¶å¯æ‰¾æˆ‘å…‘æ¢~</span>`;
        document.getElementById('giftModal').style.display = 'flex';
        controls.autoRotate = false;
        return;
    }

    // ç¬¬ä¸€æ¬¡æŠ½å¥– - éšæœºæŠ½å–
    const randomIndex = Math.floor(Math.random() * CONFIG.prizes.length);
    drawnPrize = CONFIG.prizes[randomIndex];
    hasDrawn = true;

    // æ˜¾ç¤ºæŠ½å¥–ç»“æœ
    document.getElementById('giftTitle').innerHTML = `ğŸ‰ æ­å–œ ${CONFIG.herName} ğŸ‰`;
    document.getElementById('prizeEmoji').textContent = drawnPrize.emoji;
    document.getElementById('loveMessage').innerHTML = `<strong style="font-size:1.3em;color:#c41e3a;">${drawnPrize.title}</strong><br><br>${drawnPrize.desc}<br><br><span style="color:#888;font-size:0.9em;">ğŸ“Œ æ­¤åˆ¸é•¿æœŸæœ‰æ•ˆï¼Œéšæ—¶å¯æ‰¾æˆ‘å…‘æ¢~</span>`;
    document.getElementById('giftModal').style.display = 'flex';
    controls.autoRotate = false;

    // æ”¾çƒŸèŠ±åº†ç¥
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            createFirework((Math.random()-0.5)*10, 12 + Math.random()*5, -5);
        }, i * 200);
    }
}

function closeGiftModal() {
    document.getElementById('giftModal').style.display = 'none';
    controls.autoRotate = true;
}

document.getElementById('photoViewer').onclick = function(e) {
    if (e.target === this) closePhotoViewer();
};
document.getElementById('giftModal').onclick = function(e) {
    if (e.target === this) closeGiftModal();
};

init();
    </script>
</body>
</html>
